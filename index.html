<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">

    <title>Basic Game Template</title>
    <!-- Add Javascript or game libraries here-->
    <script src="libraries/jquery-3.4.1.min.js" type="text/javascript"></script><!-- Web Manipulation-->
    <script src="libraries/howler.min.js" type="text/javascript"></script>
    <!-- Audio, http://goldfirestudios.com/blog/104/howler.js-Modern-Web-Audio-Javascript-Library -->
    <script src="libraries/jquery.hotkeys.js" type="text/javascript"></script>
    <!-- Keyboard mapping, https://github.com/tzuryby/jquery.hotkeys -->
    <script src="libraries/sprite.js" type="text/javascript"></script> <!-- Sprite Mapping,  -->
    <script src="libraries/map.js" type="text/javascript"></script> <!-- Object and Level Mapping,  -->
    <script src="libraries/tile.js" type="text/javascript"></script> <!-- Tile Mapping,  -->

    <script src="update.js" type="text/javascript"></script> <!---game engine interaction loop-->
    <script src="draw.js" type="text/javascript"></script> <!---draws to canvas loop-->
    <script src="libraries/powerup.js" type="text/javascript"></script><!--powerup config -->
</head>

<body style="margin:0px;background-image:url(images/dreamcloud.png);background-repeat-x: no-repeat;background-repeat-y: no-repeat;background-size: 75%;" >
    <script>
        //Generate the Canvas
        const CANVAS_WIDTH = 1920;
        const CANVAS_HEIGHT = 1080;
        //HD Resolutions -1280x720 and 1920 Ã— 1080 Full HD
        var canvasElement = $("<canvas id ='GameCanvasScreen' width='" + CANVAS_WIDTH + "' height='" + CANVAS_HEIGHT + "'></canvas>");
        //var fadeToBlackElement = $("<div id='overlay' width='" + CANVAS_WIDTH + "' height='" + CANVAS_HEIGHT + "></div>");
        const canvas = canvasElement.get(0).getContext("2d");
        canvasElement.appendTo('body');
        //fadeToBlackElement.append(canvasElement);
        var timer = '2m';
        /**By Ryan Giglio*/
        function scaleToSmallest() {
            var ratio = CANVAS_WIDTH / CANVAS_HEIGHT;

            if (($(window).width() / ratio) <= $(window).height()) {
                canvasElement.css('width', '100%').css('height', 'auto');
            } else {
                canvasElement.css('height', '100%').css('width', 'auto');
            }
        }
        scaleToSmallest();

        $(window).on('resize', function () {
            scaleToSmallest();
        });
        //Draw tile map
        drawMap(canvas);
        // Game State


        const states = {
            splash: 0,
            title: 1,
            Game: 2,
            End: 3,
            instruct: 4
        };
        let currentState = states.title;

        //Game Loop
        //var FPS = 60;

        // shim layer with setTimeout fallback
        window.requestAnimFrame = (() => {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                function (callback) {
                    window.setTimeout(callback, 1000 / 60);
                };
        })();
        var messageX = 0;
        var messageY = 0;
        //Mouse Coordinate Positioning
        function writeMessage(canvas, message) {
            var context = canvasid.getContext('2d');
            //context.clearRect(0, 0, canvasid.width, canvasid.height);
            context.font = '20pt Calibri';
            context.fillStyle = 'yellow';
            context.fillText(message, 20 + messageX, 75 + messageY);
            //console.log(message);
        }

        function wrapText(context, text, x, y, maxWidth, lineHeight) {
        var words = text.split(' ');
        var line = '';

        for(var n = 0; n < words.length; n++) {
          var testLine = line + words[n] + ' ';
          var metrics = context.measureText(testLine);
          var testWidth = metrics.width;
          if (testWidth > maxWidth && n > 0) {
            context.fillText(line, x, y);
            line = words[n] + ' ';
            y += lineHeight;
          }
          else {
            line = testLine;
          }
        }
        context.fillText(line, x, y);
      }

        function getMousePos(canvas, evt) {
            var rect = canvasid.getBoundingClientRect();
            return {
                x: evt.clientX - rect.left,
                y: evt.clientY - rect.top
            };
        }

        var canvasid = document.getElementById('GameCanvasScreen');
        var context = canvas;
        context.scale(1,1);
        // canvasid.addEventListener('mousemove', function (evt) {
        //     mousePos = getMousePos(canvasid, evt);
        //     var message = 'Mouse position: ' + mousePos.x + ',' + mousePos.y;
        //     writeMessage(canvas, message);
        // }, false);
var isMouseDown = false;
  $('body').mouseup(function() {
   isMouseDown = false;
 })
 .mousedown(function() {
   isMouseDown = true;
 });

        function gameloop() {
            controller();
            if (paused == false) {
                update();
                draw();
            }
            window.requestAnimFrame(gameloop);
        }

        var paused = false;

        window.requestAnimFrame(gameloop);


        //Keyboard Map
        function setUpKeys() {
            window.keydown = {};
            window.keyup = {};
            function keyName(event) {
                return jQuery.hotkeys.specialKeys[event.which] ||
                    String.fromCharCode(event.which).toLowerCase();
            }

            $(document).bind("keydown", (event) => {
                keydown[keyName(event)] = true;
            });

            $(document).bind("keyup", (event) => {
                keydown[keyName(event)] = false;
            });

            //  $(document).bind("keypress",  (event) => {
            //     keypress[keyName(event)] = false;
            //  });
        };
        setUpKeys();

        var notyet = 0;
        function clearTimer() {
            notyet = 0;
        }


        function pauseGame() {
            if (notyet == 1) {
                console.log("waiting")
                return;
            }
            notyet = 1;
            paused = !paused;
            setTimeout('clearTimer()', 500);
        }

        //console.log(keydown.esc);

        var titleImg1 = new Image();
        titleImg1.src = 'images/kobe.png';
        var titleImg2 = new Image();
        titleImg2.src = 'images/numba2.png';
        //Canvas Utlity for preventing objects from going over the edge
        Number.prototype.clamp = function (min, max) {
            return Math.min(Math.max(this, min), max);
        };

        //Text Variables
        var splashTextX = CANVAS_WIDTH / 3;
        var splashTextY = 0;
        var endTextX = CANVAS_WIDTH / 3;
        var endTextY = 0;
        var endZoomOutFactor = 1;
        //Sound creation
        var GameLoopMusic_sound = new Howl({
            src: ['sounds/ambient_space.wav'],
            autoplay: false,
            volume: 0.3,
            loop: true,
        });
        var explosion_sound = new Howl({
            src: ['sounds/alarm_beep.wav'],
            volume: 0.3,
        });

        var pickup_sound = new Howl({
            src: ['sounds/retro_collect_pickup_coin_03.wav'],
            volume: 0.4
        });

        var online_sound = new Howl({
            src: ['sounds/Bluezone_BC0235_synth_texture_002.wav'],
            volume: 0.4
        });
        var snoring_sound = new Howl({
            src: ['sounds/JM BURP Long Airy.wav'],
            volume: 0.4
        });

        var BACKGROUND_CENTER_X = CANVAS_WIDTH / 2;
        var BACKGROUND_CENTER_Y = CANVAS_HEIGHT / 2;
        //explosion_sound.play();
        let engineOff = false;
        let leftTurnOff = false;
        let rightTurnOff = false;

        var firstEngineFix = false;
        var secondEngineFix = false;

        var leftFirstFix = false;
        var leftSecondFix = false;

        var quadrant = {
           firstRoom : true,
           secondRoom : false,
           thirdRoom : false,
           fourthRoom : false
        };
        var endFlag = true;
        //Create The player
        var INIT_X = 0;
        var INIT_Y = 0;
        var player = {
            // color: "#00A",
            sprite: Sprite("sheepship"),
            x: INIT_X,
            y: INIT_Y,
            width: 64,
            height: 64,
            life: 100,
            velX: 5,
            velY: 5,
            angle: 90,
            speed: 0,
            friction: 0.85,
            keyboardTurnSpeed: 1,
            keyboardThrust: 5,
            i: 0,
            rotate: function () {
                canvas.save();
                canvas.translate(this.x + (this.width / 2), this.y + (this.height / 2));
                // Rotate the canvas so the boat draws turned
                canvas.rotate(this.angle * Math.PI / 180);
               // console.log(this.angle * Math.PI / 180);
                // Reset the canvas to pre-rotated
                // Draw the boat
                this.sprite.draw(canvas, -(this.width / 2), -(this.height / 2));
                //canvas.rotate(-this.angle);
                canvas.restore();
                //canvas.translate(-(this.x + (this.width / 2)), -(this.y + (this.height / 2)));
            },
            update: function () {
                // Keyboard controls for development
                // Calculate distance to center
                var dx = BACKGROUND_CENTER_X - this.x;
                var dy = BACKGROUND_CENTER_Y - this.y;
                var centerDistance = Math.sqrt((dx * dx) + (dy * dy));
                var velX = Math.cos((this.angle - 90) * Math.PI / 180) * this.speed;
                var velY = Math.sin((this.angle - 90) * Math.PI / 180) * this.speed;

                this.x += velX;
                this.y += velY;

                this.x = this.x.clamp(0 + this.width - 200, CANVAS_WIDTH - this.width); //prevents character from going past canvas


                this.y = this.y.clamp(0, CANVAS_HEIGHT - this.height);
                this.speed = 0;
            },
            draw: function () {
                //canvas.fillStyle = this.color;
                // canvas.fillRect(this.x, this.y, this.width, this.height);
                this.rotate();
                //this.sprite.draw(canvas, this.x, this.y);
            },
            shoot: function () {
                var bulletPosition = this.midpoint();
                shoot_sound.play();

                playerBullets.push(Bullet({
                    speed: 5,
                    x: bulletPosition.x,
                    y: bulletPosition.y
                }))
            },
            launch: function () {
                var missilePostition = this.midpoint();
                console.log(Missle.width);
                playerMissiles.push(Missle({
                    speed: 2,
                    x: missilePostition.x - 500,
                    y: missilePostition.y
                }))
            },
            midpoint: function () {
                return {
                    x: this.x + this.width / 2,
                    y: this.y + this.height / 2
                };
            },
            explode: function () {
                this.active = false;
                //explosion_sound.play();
                GameLoopMusic_sound.fade(1,0, 2000);
                currentState = states.End;
                // An explosion sound and then end the game
            },
            lifeChange: function (change) {


                this.life = this.life + change; //Adds or subtracts health based on the value added in the function

                if (this.life <= 0) {
                    this.explode();
                }

                return this.life;


            },
            points: 0,
        };

        railArray = [0,0];
        
        function drawrail(){
    
            canvas.beginPath();
            canvas.moveTo(0,0);
            for (let index = 0; index < railArray.length; index= index+2) {
                //const element = array[index];
                canvas.lineTo(railArray[index],railArray[index+1]);
                  
            }
            
            //canvas.lineTo(200, 160);
            canvas.lineWidth = 2;
            canvas.strokeStyle = 'pink';
            canvas.stroke();
        }
        var playerBullets = [];

        function Bullet(I) {
            I.active = true;

            I.xVelocity = 0;
            I.yVelocity = -I.speed;
            I.width = 3;
            I.height = 3;
            I.color = "#000";

            I.inBounds = function () {
                return I.x >= 0 && I.x <= CANVAS_WIDTH &&
                    I.y >= 0 && I.y <= CANVAS_HEIGHT;
            };

            I.draw = function () {
                canvas.fillStyle = this.color;
                canvas.fillRect(this.x, this.y, this.width, this.height);
            };

            I.update = function () {
                I.x += I.xVelocity;
                I.y += I.yVelocity;

                I.active = I.active && I.inBounds();
            };

            return I;
        }

        var playerMissiles = [];

        function Missle(I) {
            I.active = true;

            I.xVelocity = 0;
            I.mousePosX = mousePos.x;
            I.mousePosY = mousePos.y;
            I.yVelocity = -I.speed;
            I.width = 1002;
            I.height = 32;
            I.color = "#34DDDD";

            I.inBounds = function () {
                return I.x >= 0 && I.x <= CANVAS_WIDTH &&
                    I.y >= 0 && I.y <= CANVAS_HEIGHT;
            };

            I.draw = function () {
                canvas.fillStyle = this.color;
                canvas.fillRect(this.x, this.y, this.width, this.height);
            };

            I.update = function () {
                I.x += I.mousePosX;
                I.y += I.mousePosY + I.yVelocity;

                I.active = I.active && I.inBounds();
            };

            return I;
        }

        var lastEnemyLocX = 300;
        var lastEnemyLocY = 0;
        var enemyShift =0;
        var enemies = [];
        var powerups = [];
        var restArea = {
          x : 10,
          y : CANVAS_HEIGHT - 150,
          width : 150,
          height :150,
          sprite : Sprite("bed"),
          draw : function(){
              this.sprite.draw(canvas, this.x, this.y);
          }
        }
        function Enemy(I, locX, locY, spinning, type, rotation, upDown, up) {
            I = I || {};
            I.active = true;
            I.age = Math.floor(Math.random() * 128);
            I.rotateRight = true;
            I.sprite = Sprite("alarm_clock");
            // I.color = "#A2B";
            I.spinning = spinning;
            I.x = locX;
            I.y = locY;
            I.xVelocity = 0;
            I.yVelocity = 0;
            I.angle = 0;
            I.width = 57;
            I.height = 59;
            I.type = type;
            I.rotation = rotation;
            I.rotateRight = true;
            I.rotateLeft = false;
            I.upDown = upDown;
            I.down = true;
            I.up = false;
            I.inBounds = function () {
                return I.x >= 0 && I.x <= CANVAS_WIDTH &&
                I.y >= 0 && I.y <= CANVAS_HEIGHT;
            };

            I.draw = function () {
                //canvas.fillStyle = I.color;
                //canvas.fillRect(I.x, I.y, I.width, I.height);
                I.sprite.draw(canvas, I.x, I.y);
            };
            I.rotate = function (){
              /*  if(I.angle < 360 && I.rotateRight === true){
                    I.angle += I.rotation;
                }
                else if(I.angle > 360 && I.rotateRight === false){
                    I.angle -= I.rotation;
                }

                if(I.angle === 360 && I.rotateRight === true){
                    I.rotateRight = false;
                }
                else if(I.angle === 0 && I.rotateRight === false){
                    I.rotateRight = true;
                }*/
                I.angle += I.rotation;
                //var dx = 0 - I.x;
                //var dy = 1080 - I.y;
               // var centerDistance = Math.sqrt((dx * dx) + (dy * dy));

                var velX = Math.cos((Math.random() * I.angle) * Math.PI / 180) * I.type;
                var velY = Math.sin((I.angle) * Math.PI / 180) * I.type;
               // var radius = (1080 - I.y) / (2*Math.PI)
                //var velX = 0 + Math.cos(I.angle) * radius;
                //var velY = 1080 + Math.sin(I.angle)* radius;
               // console.log("Y " + velY)
                I.x += velX;
                I.y += velY;
                canvas.save();
                canvas.translate(I.x + (CANVAS_WIDTH.width / 2), I.y + (CANVAS_HEIGHT.height / 2));

                canvas.rotate(I.angle * Math.PI / 180);
               // console.log(this.angle * Math.PI / 180);
                // Reset the canvas to pre-rotated
                // Draw the boat
                //I.sprite.draw(canvas, -(I.width / 2), -(I.height / 2));
                //canvas.rotate(-this.angle);
                canvas.restore();
            };
            I.explode = function () {
                I.active = true;
                player.x = savedX;
                player.y = savedY;
                explosion_sound.play();
                // Extra Credit: Add an explosion graphic
            };

            I.update = function () {
                if(upDown === true){
                //    if(up === false){
                    if(I.y < locY + 350 && I.down === true){
                    
                            I.y += 2;
                        
                    }
                    if(I.y > locY + 350){
                        I.down = false;
                    }
                    if(I.y > locY && I.down === false){
                        
                            I.y -= 2;
                    
                    }
                    if(I.y < locY && I.down === false){
                        I.down =true;
                    }
                /* }else{
                    if(I.y < locY - 100 && I.down === true){
                        
                            I.y -= 2;
                    }
                    if(I.y > locY - 100){
                        I.down = false;
                    }
                    if(I.y > locY && I.down === false){
                            I.y += 2;
                        
                    }
                    if(I.y < locY && I.down === false){
                        I.down =true;
                    }
                    }
                }
*/
                //I.x += I.x;
                //I.y += I.y;


                //I.x = I.x.clamp(0 + I.width - 200, CANVAS_WIDTH - I.width); //prevents character from going past canvas


                //this.y = this.y.clamp(0, CANVAS_HEIGHT - this.height);
            };
        };
            return I;
        };
        //create asteroids

        //Collision Detection
        function collides(a, b) {
            return a.x < b.x + b.width &&
                a.x + a.width > b.x &&
                a.y < b.y + b.height &&
                a.y + a.height > b.y;
        }


        function collisionDetection() {

            /*
             * private function initialize()
             *
             * Initializes the object
             *
             */
            this.initialize = function () { }

            /*
             * public function hitTest()
             *
             * Checks if two objects collide. First with box-model detection
             * and then on a per-pixel detection.
             *
             * Both source and target objects are expected to look like this:
             *
             * {
             *    x: (Number) current x position,
             *    y: (Number) current y position,
             *    width: (Number) object height,
             *    height: (Number) object width,
             *    pixelmap: (Object) pixel map object generated from buildPixelMap()
             * }
             *
             * @param source (Object) The source object
             * @param target (Object) The target object
             *
             * @return boolean, true on collision
             *
             */
            this.hitTest = function (source, target) {
                var hit = false;
                var start = new Date().getTime();

                if (this.boxHitTest(source, target)) {
                    if (this.pixelHitTest(source, target)) {
                        hit = true;
                    }
                }

                var end = new Date().getTime();

                if (hit == true) {
                    //console.log( 'detection took: ' + (end - start) + 'ms' );
                }

                return hit;
            }

            /*
             * private function boxHitTest()
             *
             * Checks if two objects collide with box-model detection.
             *
             * Both source and target objects are expected to look like this:
             *
             * {
             *    x: (Number) current x position,
             *    y: (Number) current y position,
             *    width: (Number) object height,
             *    height: (Number) object width
             * }
             *
             * @param source (Object) The source object
             * @param target (Object) The target object
             *
             * @return boolean, true on collision
             *
             */
            this.boxHitTest = function (source, target) {
                return !(
                    ((source.y + source.height) < (target.y)) ||
                    (source.y > (target.y + target.height)) ||
                    ((source.x + source.width) < target.x) ||
                    (source.x > (target.x + target.width))
                );
            }

            /*
             * private function pixelHitTest()
             *
             * Checks if two objects collide on a per-pixel detection.
             *
             * Both source and target objects are expected to look like this:
             *
             * {
             *    x: (Number) current x position,
             *    y: (Number) current y position,
             *    width: (Number) object height,
             *    height: (Number) object width,
             *    height: (Number) object width,
             *    pixelmap: (Object) pixel map object generated from buildPixelMap()
             * }
             *
             * @param source (Object) The source object
             * @param target (Object) The target object
             *
             * @return boolean, true on collision
             *
             */
            this.pixelHitTest = function (source, target) {

                var top = parseInt(Math.max(source.y, target.y));
                var bottom = parseInt(Math.min(source.y + source.height, target.y + target.height));
                var left = parseInt(Math.max(source.x, target.x));
                var right = parseInt(Math.min(source.x + source.width, target.x + target.width));

                for (var y = top; y < bottom; y++) {
                    for (var x = left; x < right; x++) {
                        var pixel1 = source.pixelMap.data[(x - source.x) + "_" + (y - source.y)];
                        var pixel2 = target.pixelMap.data[(x - target.x) + "_" + (y - target.y)];

                        if (!pixel1 || !pixel2) {
                            continue;
                        };

                        if (pixel1.pixelData[3] == 255 && pixel2.pixelData[3] == 255) {
                            return true;
                        }
                    }
                }

                return false;
            }

            /*
             * public function buildPixelMap()
             *
             * Creates a pixel map on a canvas image. Everything
             * with a opacity above 0 is treated as a collision point.
             * Lower resolution (higher number) will generate a faster
             * but less accurate map.
             *
             *
             * @param source (Object) The canvas object
             * @param resolution (int)(DEPRECATED!) The resolution of the map
             *
             * @return object, a pixelMap object
             *
             */
            this.buildPixelMap = function (source) {
                var resolution = 1;
                var ctx = source.getContext("2d");
                var pixelMap = [];

                for (var y = 0; y < source.height; y++) {
                    for (var x = 0; x < source.width; x++) {
                        var dataRowColOffset = y + "_" + x;//((y * source.width) + x);
                        var pixel = ctx.getImageData(x, y, resolution, resolution);
                        var pixelData = pixel.data;

                        pixelMap[dataRowColOffset] = { x: x, y: y, pixelData: pixelData };

                    }
                }
                return {
                    data: pixelMap,
                    resolution: resolution
                };
            }

            // Initialize the collider
            this.initialize();

            // Return our outward facing interface.
            return {
                hitTest: this.hitTest.bind(this),
                buildPixelMap: this.buildPixelMap.bind(this)
            };
        };
        var myNewCollission = new collisionDetection();
        function handleCollisions() {
            playerBullets.forEach(function (bullet) {
                enemies.forEach(function (enemy) {
                    if (collides(bullet, enemy)) {
                        enemy.explode();
                        bullet.active = false;
                    }
                });
            });


            playerMissiles.forEach(function (missle) {
                enemies.forEach(function (enemy) {
                    if (collides(missle, enemy)) {
                        enemy.explode();
                        missle.active = false;
                    }
                });
            });

            enemies.forEach(function (enemy) {
                if (collides(enemy, player)) {
                    enemy.explode();
                    player.lifeChange(-10);
                }
            });

            //PowerUp Collision
	    	powerups.forEach(function(powerup) {
				if (collides(powerup, player)) {
						powerup.explode();
						  player.lifeChange(30);
              player.points += 1;
              railArray.push(player.x,player.y);
				}
		    });

        if(collides(restArea, player)){
            if (endFlag == true){
                setTimeout(function(){
                currentState = states.End;
                 }, 3000);
                 endFlag = false;
            }
           

          
        }

        }

        /*** Parallax background tutorial http://javacoffee.de/?p=866 **/
        //Parallax background

        /**
         * Data structure to hold layer data
         * @param s <string> Absolute path to the image
         * @param x <int> X coordinate
         * @param Y </int><int> Y coordinate
         */
        function Layer(s, x, y) {
            this.img = new Image();
            this.img.src = s;
            this.x = x;
            this.y = y;
        }


        /**
         * Main ParallaxScrolling class
         * @param ctx <context> Canvas context
         * @param imgdata <array> Array with absolute image paths
         */
        function ParallaxScrolling(canvas, imgdata) {
            var self = this;
            if (typeof imgdata === 'undefined') {
                imgdata = []; //fill it with paths to images for the parralax
            };
            this.canvas = canvas;

            // Initialize the layers
            this.layers = new Array(imgdata.length);
            for (i = 0; i < imgdata.length; i++) {
                this.layers[i] = new Layer(imgdata[i], 0, 0);
            }

            // Function: Move all layer except the first one
            this.Move = function () {
                for (var i = 1; i < self.layers.length; i++) {
                    if (self.layers[i].x > self.layers[i].img.width) self.layers[i].x = 0;
                    self.layers[i].x += i;
                }
            };

            // Function: Draw all layer in the canvas
            this.Draw = function () {
                self.Move();
                for (var i = 0; i < self.layers.length; i++) {
                    var x1 = (self.layers[i].x - self.layers[i].img.width);
                    self.canvas.drawImage(self.layers[i].img, 0, 0, self.layers[i].img.width, self.layers[i].img.height,
                        self.layers[i].x, 0, self.layers[i].img.width, self.layers[i].img.height);
                    self.canvas.drawImage(self.layers[i].img, 0, 0, self.layers[i].img.width, self.layers[i].img.height,
                        x1, 0, self.layers[i].img.width, self.layers[i].img.height);
                }
            }
        }

        var layer = new Array('images/TheStarfield.png', 'images/emptytile.png');
        var parallax = new ParallaxScrolling(canvas, layer);

        function controller() {
            //Pause the game
            if (keydown.p) {

                pauseGame();
                console.log(paused);

            }

        }
        function breakShip(whichPart){
            if(whichPart == "engine"){
            engineOff = true;
            }
            if(whichPart == "leftWing"){
            leftTurnOff = true;
            }
            if(whichPart == "rightWing"){
            rightTurnOff = true;
            }
        }
        let isThereAnEventHappening = false;
        let message = "";
        let savedX = 0;
        let savedY = 0;
        function triggerEvent(){
            var ev = Math.floor(Math.random() * 3);
            isThereAnEventHappening = true;

            savedX = player.x;
            savedY = player.y;
            switch(ev) {
            case 0:
                message = "Engine Down! Hit the Hay 'Down Arrow/ HAMMER DOWN' x2"
                breakShip("engine");
                break;

            case 1:
                message = "Saw the log Press 'Space/Saw' x2"
                breakShip("leftWing");
                break;

            case 2:
                message = "Fire! Time for lights out 'Click' x1"
                breakShip("rightWing");
                break
        }
    }

    	powerups.push(Powerup(0,50,50));
      powerups.push(Powerup(0,150,150));
      powerups.push(Powerup(0,250,350));
      powerups.push(Powerup(0,350,50));
      powerups.push(Powerup(0,450,150));
      powerups.push(Powerup(0,650,350));

      powerups.push(Powerup(0,750,50));
      powerups.push(Powerup(0,850,150));
      powerups.push(Powerup(0,950,350));
      powerups.push(Powerup(0,1050,50));
      powerups.push(Powerup(0,1150,150));
      powerups.push(Powerup(0,1250,350));

      powerups.push(Powerup(0,750,450));
      powerups.push(Powerup(0,850,550));
      powerups.push(Powerup(0,950,650));
      powerups.push(Powerup(0,1050,750));
      powerups.push(Powerup(0,1150,850));
      powerups.push(Powerup(0,1250,950));

      powerups.push(Powerup(0,1350,50));
      powerups.push(Powerup(0,1450,150));
      powerups.push(Powerup(0,1550,350));
      powerups.push(Powerup(0,1650,50));
      powerups.push(Powerup(0,1750,150));
      powerups.push(Powerup(0,1850,350));

      powerups.push(Powerup(0,1350,450));
      powerups.push(Powerup(0,1450,550));
      powerups.push(Powerup(0,1550,650));
      powerups.push(Powerup(0,1650,750));
      powerups.push(Powerup(0,1750,850));
      powerups.push(Powerup(0,1850,950));

      enemies.push(Enemy(0,0,230, true, .1,1));
      enemies.push(Enemy(0,58,240, true, .1,1));
      enemies.push(Enemy(0,120,250, true, .1,1));
      enemies.push(Enemy(0,160,260, true, .1,1));
      enemies.push(Enemy(0,220,270, true, .1,1));
      enemies.push(Enemy(0,280,275, true, .1,1));
      enemies.push(Enemy(0,340,280, true, .1,1));
      enemies.push(Enemy(0,400,290, true, .1,1));
      enemies.push(Enemy(0,460,300, true, .1,1));
      enemies.push(Enemy(0,520,300, true, .1,1));
      enemies.push(Enemy(0,580,300, true, .1,1));
      enemies.push(Enemy(0,640,305, true, .1,1));
      enemies.push(Enemy(0,700,50, true, .3,1, true));
      enemies.push(Enemy(0,760,90, true, .5,2.5, true));
      enemies.push(Enemy(0,820,150, true, .5,2, true));
      enemies.push(Enemy(0,880,50, true, .5,2,true));
      enemies.push(Enemy(0,940,75, true, .5,3, true));
      enemies.push(Enemy(0,1000,50, true, .5,2,true));
      enemies.push(Enemy(0,1060,300, true, .1,1));
      enemies.push(Enemy(0,1120,290, true, .1,1));
      enemies.push(Enemy(0,1180,280, true, .1,1));
      enemies.push(Enemy(0,1240,270, true, .1,1));
      enemies.push(Enemy(0,1280,260, true, .1,1));
      enemies.push(Enemy(0,1340,200, true, .1,1));
      enemies.push(Enemy(0,1400,180, true, .1,1));
      enemies.push(Enemy(0,1460,200, true, .1,1));
      enemies.push(Enemy(0,1500,230, true, .1,1));
      enemies.push(Enemy(0,1560,250, true, .1,1));
      enemies.push(Enemy(0,1620,280, true, .1,1));
      enemies.push(Enemy(0,1635,340, true, .1,1));
      enemies.push(Enemy(0,1645,400, true, .1,1));
      enemies.push(Enemy(0,1640,440, true, .1,1));
      enemies.push(Enemy(0,1625,500, true, .1,1));
      enemies.push(Enemy(0,1610,550, true, .1,1));
      enemies.push(Enemy(0,1560,850, true, .1,1));
      enemies.push(Enemy(0,1500,800, true, .1,1));
      enemies.push(Enemy(0,1600,900, true, .1,1));
      enemies.push(Enemy(0,1660,950, true, .1,1));
      enemies.push(Enemy(0,1720,990, true, .1,1));
      enemies.push(Enemy(0,1460,785, true, .1,1));
      enemies.push(Enemy(0,1400,760, true, .1,1));
      enemies.push(Enemy(0,1340,720, true, .1,1));
      enemies.push(Enemy(0,1280,700, true, .1,1));
      enemies.push(Enemy(0,1240,665, true, .1,1));
      enemies.push(Enemy(0,1180,670, true, .1,1));
      enemies.push(Enemy(0,1120,675, true, .1,1));
      
      enemies.push(Enemy(0,1060,670, true, .1,1));
      enemies.push(Enemy(0,1000,675, true, .1,1));
      enemies.push(Enemy(0,940,350, true, .1,1,true));
      enemies.push(Enemy(0,880,355, true, .1,1,true));
      enemies.push(Enemy(0,820,355, true, .1,1,true ));
      enemies.push(Enemy(0,640,675, true, .1,1));

      enemies.push(Enemy(0,940,675, true, .1,1));
      enemies.push(Enemy(0,880,675, true, .1,1));
      enemies.push(Enemy(0,820,675, true, .1,1));
      enemies.push(Enemy(0,760,675, true, .1,1));
      enemies.push(Enemy(0,700,660, true, .1,1));
      enemies.push(Enemy(0,640,665, true, .1,1));
      enemies.push(Enemy(0,580,670, true, .1,1));
      enemies.push(Enemy(0,520,650, true, .1,1));
      enemies.push(Enemy(0,460,640, true, .1,1));
      enemies.push(Enemy(0,400,630, true, .1,1));
      enemies.push(Enemy(0,340,620, true, .1,1));
      enemies.push(Enemy(0,280,615, true, .1,1));
      enemies.push(Enemy(0,0,700, true, .1,1));
      enemies.push(Enemy(0,60,740, true, .1,1));
      enemies.push(Enemy(0,120,760, true, .1,1));
      enemies.push(Enemy(0,180,780, true, .1,1));
      enemies.push(Enemy(0,240,790, true, .1,1));
      enemies.push(Enemy(0,300,800, true, .1,1));
      enemies.push(Enemy(0,360,825, true, .1,1));
      enemies.push(Enemy(0,420,835, true, .1,1));
      enemies.push(Enemy(0,480,845, true, .1,1));
      enemies.push(Enemy(0,540,850, true, .1,1));
      enemies.push(Enemy(0,600,860, true, .1,1));
      enemies.push(Enemy(0,660,865, true, .1,1));
      enemies.push(Enemy(0,720,870, true, .1,1));
      enemies.push(Enemy(0,780,875, true, .1,1));
      enemies.push(Enemy(0,840,885, true, .1,1));
      enemies.push(Enemy(0,900,890, true, .1,1));
      enemies.push(Enemy(0,960,900, true, .1,1));

    //   setInterval(function(){
    // // //   console.log("updating the canvas");
    // var previousX = 0;
    //   console.log(player.x);
    //
    //   if( (player.x - previousX) >= 10){
    //        context.translate(player.x/10, 0);
    //        //context.translate(-player.x, 0);
    //        player.x = 0;
    //        console.log(previousX);
    //     //   debugger;
    //   }
    //
    //
    // }, 3000);
     
    </script>
</body>

</html>
